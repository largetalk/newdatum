======================================================
Understanding CPU utilization
======================================================

进程类型
=============================

交互式进程不断与用户之间交互，因此大部分时间等待键盘按键和鼠标操作。但收到输入， 进厂必须马上唤醒，否则用户会觉得系统反应迟钝。一般来说，平均延迟必须小于50到150毫秒。延迟的变动也必须有界，否则用户会发现系统不稳定。典型的交互程序有命令行，文本编辑器和图像软件。

批处理进程不叙永用户交互，因此经常在后台运行。因为此类进程不需很快的反应， 所以他们常被调度器惩罚。典型的批处理程序有编译器，数据库搜索引擎和科学技术等。

linux2.6 调度器使用了一个设计精巧复杂的算法, 该算法会基于进程过往的行为来决定一个进程应该被当作交互程序还是批处理程序。当然，相比批处理程序，调度器更倾向于喜欢交互进程。

实时进程有非常严格的调度要求。此类进程应从不会被低优先级的进程阻塞并在很低变化下有最低保证反应时间。典型的实时程序有视频和音频程序，机器人控制以及从物理感应器上收集数据的程序。（进程的优先级小于100)

动态和静态优先级
===============================

静态优先级是分配给进程的优先级。它决定了分配给每个进程的时间分片(100 是 800ms, 120 是 100ms， 139是5ms). 一个新的进程继承它父进程的静态优先级。但是，用户可以使用nice更改静态优先级. 所有的进程起始有个默认的优先级，默认值120.

动态优先级是基于进程的平均睡眠时间合理真假或减小静态优先级。动态优先级决定了进程在运行队列(run queue)中的位置

进程调度
=============================

linux进程（LWPs(light wieght processes)和进程是同样的调度）是抢占式。但一个进程进入TASK_RUNNING状态，内核检查他的动态优先级是否大于当前正在运行进程的优先级。如果是，当前执行的进程被中断，调用调度器选择另一个进程执行（通常是刚可以runable的）。当然，一个进程当其时间分片到时时也会被抢占。注意，被抢占进程不是被暂停，因为它的状态还是TASK_RUNNING，只是简单的不再使用cpu

进程调度算法粗览
=============================

* 选择一个进程
* 如果一个新进程进入队列-如果它的优先级大于这个进程，则pre_empt. 如果不是，放入队列
* 进程是否完成
  * 是：时间分片已到期
    * 是：退出
    * 否： 激活队列，从队列中选取最高优先级进程（如果队列空则失效队列）并重复
* 时间分片已到期
  * 否：活动队列
  * 是： 进程是个交互进程
    * 否： 失效队列
    * 是： 是否有高优先级的过期进程或者上次执行以来过去很长时间的进程
      * 是：将进程放入失效队列
      * 否： 讲进程放入活动队列
* 从活动队列（如果空则是失效队列）选取最高优先级的进程并重复

上面的过程确保了如下：
* 动态优先级高的进程总能立马抢占动态优先级低的进程
* 一个进程不能独占cpu超过由静态优先级决定的x毫秒
* 交互进程比批处理更高优先级
* 任何进程用完它的时间分片必须等待直到其他相同或更高优先级进程执行完

上下文切换开销
===================================

为了控制进程的运行, 内核必须能暂停当前在cpu上执行的进程和恢复以前被暂停的进程执行。这个被称为进程切换，任务切换或上下文切换. 一个上下文切换可能是自愿的-当一个进程在分配给它的时间分片消化完之前完成工作或者因为调用一个阻塞IO操作而进入暂停状态。非此即彼，一个上下文切换可能是非自愿的如进程使用完分配给他的cpu分片时间，内核会抢占该进程并切换出去将cpu授予run queue中其他进程。暂停第一个进程和调度第二个需要内核保存一个进程的状态以及加载第二个进程的状态。它的开销和需要的时间被认为是上下文切换的开销。
