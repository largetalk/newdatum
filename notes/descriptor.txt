翻译 http://docs.python.org/2/howto/descriptor.html
Arthor:Arthur
Date:2012-11-26

一般说来， descriptor 是一种有“绑定行为”的对象属性， 属性在存取时被descriptor协议定义的方法所覆盖。这些方法是__get__, __set__ 和__delete__。 如果一个对象定义了这些方法，它就被任务是一个descriptor.
对象属性存取默认行为是get, set或delete对象字典中的属性。对于实例a.x查找链是从a.__dict__['x']开始，然后type(a).__dict__['x'],再就是type(a)的父类（不包括metaclass).如果查找的value是定义了任一descriptor方法的对象，python可能会重载默认行为并调用descriptor方法代替。在优先链哪里发生取决于哪个descriptor方法被定义。注意，descriptor仅在新型对象或类中有效（新型类是继承于object或type的类）
descriptor是强力，通用的协议。它是隐藏在properties, method, static methods, class methods 和 super()后面的机制。在2.2版本，python用之实现新型类。descriptors简化底层c代码并为python程序员提供一个灵活的工具集

descriptor协议
descr.__get__(self, obj, type=None) --> value
descr.__set__(self, obj, value) --> None
descr.__delete__(self, obj) --> None
所有就这些。对象定义其中任何方法都被认为是descriptor并且可以改变属性查找默认行为。
如果一个对象同时定义了__get__和__set__， 它被认为是一个data descriptor. 如果仅定义__get__被non-data descriptor（典型应用是方法，或作其他用途）
data和non-data descriptor不同在于与实例字典中的项优先级上。如果一个实例字典有一个与data decriptor同名的项， data descriptor优先.如果是与non-data descriptor同名， 字典优先。
如果要定义一个只读data descriptor， 定义__get__和__set__, 调用__set__时抛出一个AttributeError异常。定义一个有异常的__set__方法是为了满足data descriptor.

调用descriptor
descriptor可以直接用方法名调用， 如d.__get__(obj)
另外，更常见的是通过属性自动调用。如， obj.d在obj的字典中查找d。如果d定义了__get__方法， 则d.__get__(obj)按照后面介绍的优先规则被调用。
调用细节取决于obj是对象还是类。不管怎样， descriptor只在新型类（object的子类）中起作用。
对于对象，object.__getattribute__的机制是转化b.x成type(b).__dict__['x'].__get__(b, type(b)).这种实现方式让data descriptor在优先链上优先级高于实例变量。实例变量高于non-datadescriptor，并给于__getattr__最低的优先级。C实现可以在Object/object.c的PyObject_GeneriGetAttr()中找到
对于类， type.__getattribute_的机制是转化B.x成B.__dict__['x'].__get__(None, B)。 在纯python中，看起来是：
def __getattribute__(self, key):
    v = object.__getattribute__(self, key)
    if hasattr(v. '__get__'):
        return v.__get__(None, self)
    return v
需要记住的几点是：
  descriptors 是由__getattribute__调用的
  重载__getattribute__阻止了自动的descriptor调用
  __getattribute__是只有新型类和对象才有的
  object.__getattribute__ 和 type.__getattribute__不同的调用__get__
  data descriptor覆盖实例字典项
  non-data descriptor 被字典项覆盖
由super返回的对象也有个__getattribute__方法调用descriptor. super(B, obj).m() 搜索obj.__class__.__mro__ 找到父类A然后返回A.__dict__['m'].__get(obj, A).如果不是descriptor, 返回的m不变.如果不在字典， m回到object.__getattribute__重新查找
注意， 在python2.2中， 如果仅当m是data descriptor，super(B,obj).m()才会调用__get__()。而在python2.3中，non-data descriptor也会被调用，除非B是旧型（经典）类。实现细节在objects/typeobject.c的super_getattro()，纯python等价物可在guido的指南中找到。
上面显示的descriptor机制和细节都内嵌到object, type和super（）的__getattribute__方法中。当类继承于object或他们的meta-class提供相似功能时，类继承这些机制。同样，类可以通过重载__getattribute__关闭descriptor调用。

descriptor例子
下面的代码创建了一个是data descriptor的类，它在每次get或set时都打印一条消息。如想更改所有属性行为，重载__getattribute__是一个替代办法。尽管如此，如更改小部分属性，descriptor是个好办法。
class RevealAccess(object):
    """A data descriptor that sets and returns values
       normally and prints a message logging their access.
    """

    def __init__(self, initval=None, name='var'):
        self.val = initval
        self.name = name

    def __get__(self, obj, objtype):
        print 'Retrieving', self.name
        return self.val

    def __set__(self, obj, val):
        print 'Updating' , self.name
        self.val = val

>>> class MyClass(object):
    x = RevealAccess(10, 'var "x"')
    y = 5

>>> m = MyClass()
>>> m.x
Retrieving var "x"
10
>>> m.x = 20
Updating var "x"
>>> m.x
Retrieving var "x"
20
>>> m.y
5
descriptor 协议非常简单且提供另人兴奋的可能性。几个使用例子是如此普通以至于他们都被整理成单独的涵数调用。properties, bound 和 非bound 方法，static方法， class方法都是基于descriptor 协议。

Properties
调用property()是一个非常简洁方式来构建一个data descriptor使得存取属性会触发函数。它的原型是
property(fget=None, fset=None, fdel=None, doc=None) -> property attribute
下面文档展示了一个典型应用，定义一个被管理的属性x：
class C(object):
    def getx(self): return self.__x
    def setx(self, value): self.__x = value
    def delx(self): del self.__x
    x = property(getx, setx, delx, "I'm the 'x' property.")

来看看property()是如何根据descriptor 协议来实现的， 下面是个纯python实现的等价物：
class Property(object):
    "Emulate PyProperty_Type() in Objects/descrobject.c"

    def __init__(self, fget=None, fset=None, fdel=None, doc=None):
        self.fget = fget
        self.fset = fset
        self.fdel = fdel
        self.__doc__ = doc

    def __get__(self, obj, objtype=None):
        if obj is None:
            return self
        if self.fget is None:
            raise AttributeError, "unreadable attribute"
        return self.fget(obj)

    def __set__(self, obj, value):
        if self.fset is None:
            raise AttributeError, "can't set attribute"
        self.fset(obj, value)

    def __delete__(self, obj):
        if self.fdel is None:
            raise AttributeError, "can't delete attribute"
        self.fdel(obj)

内建property()使得无论何时用户接口打算访问属性并且在方法中随之做出改变。
比如， 一个spreadsheet类打算通过Cell('b10').value访问一个cell的值, 程序要求在每次访问之后随之重新计算cell的值；然而，程序员不希望客户端代码直接存取属性。解决方法是包装属性成一个property data descriptor.
class Cell(object):
    . . .
    def getvalue(self, obj):
        "Recalculate cell before returning value"
        self.recalc()
        return obj._value
    value = property(getvalue)

函数和方法
python的面向对象特性是建立于基于函数的环境。因为non-data descriptor，两者无缝合并。
类字典如同函数一样存储方法。在类定义中， 方法使用def和lambda, 如同创建函数一样。和正常函数不一样的是第一个参数是预留给对象实例的。按python惯例，实例引用被叫做self，但是也可以叫做this或其它变量名。
为了支持调用方法， 在访问属性时含有__get__()的函数是绑定方法。这意味着，所有函数都是non-data descriptor，更加调用者是对象还是类返回bound或unbound方法。纯python展示如下：
class Function(object):
    . . .
    def __get__(self, obj, objtype=None):
        "Simulate func_descr_get() in Objects/funcobject.c"
        return types.MethodType(self, obj, objtype)
在解释中展示function descriptor是如何实际工作的
>>> class D(object):
     def f(self, x):
          return x

>>> d = D()
>>> D.__dict__['f'] # Stored internally as a function
<function f at 0x00C45070>
>>> D.f             # Get from a class becomes an unbound method
<unbound method D.f>
>>> d.f             # Get from an instance becomes a bound method
<bound method D.f of <__main__.D object at 0x00B18C90>>
输出显示bound和unbound方法是两个不同类型。而它们可能是被实现如此， 在实际的实现C代码（Objects/classobjec.c的PyMethod_Type）中，是一个对象，两种不同表示，取决于im_self字段被设置与否.
同样， 调用方法的效果也依赖于im_self. 如果im_self有值（绑定），原始函数（存在im_func)被调用且第一个参数设置为实例。如果未绑定， 所有参数不作更改传给原始函数。实际C实现代码instancemethod_call看起来比较负责仅仅是包括一些类型检查。

static method 和 class method
non-data descriptor提供一种简单机制绑定函数成方法
重温一次， 函数含有__get__(), 所以能将访问属性转成方法。non-data descriptor转化obj.f(*args)成f(obj, *args), 调用klass.f(*args)成f(*args).
这个chart简介了bind和两种有用的变种
Transformation	Called from an Object	Called from a Class
function	f(obj, *args)	f(*args)
staticmethod	f(*args)	f(*args)
classmethod	f(type(obj), *args)	f(klass, *args)

static method不做任何改变返回下面的函数。调用c.f或C.f都是相当于查找到object.__getattribute__(c, "f")或object.__getattribute__(C, "f"). 结果是， 函数无论从对象或类访问都变得一样。
适合static method的方法都是不需要引用self变量
例如， 一个统计包可能包含一个处理实验数据的容器类。类提供正常方法来计算均值，中值和其他基于数据的统计公式。然而， 可能有些函数是概念相关去独立于数据的，如erf(x)在统计工作中是一个便利转换程式却不直接依赖于数据。它既能从对象调用s.erf(1.5)又能从类调用Sample.erf(1.5).
因为staticmethod是直接返回下面的函数， 例子非常乏味：
>>> class E(object):
     def f(x):
          print x
     f = staticmethod(f)

>>> print E.f(3)
3
>>> print E().f(3)
3
一个纯python版本staticmethod如下：
class StaticMethod(object):
 "Emulate PyStaticMethod_Type() in Objects/funcobject.c"

 def __init__(self, f):
      self.f = f

 def __get__(self, obj, objtype=None):
      return self.f

不同于static method， class method在调用函数前预先在参数列表中有类引用。格式是一样，无论调用者是对象还是类。
>>> class E(object):
     def f(klass, x):
          return klass.__name__, x
     f = classmethod(f)

>>> print E.f(3)
('E', 3)
>>> print E().f(3)
('E', 3)

当函数仅需要类引用而不关心任何下面数据时这种行为非常有用。classmethod一个用处是创建可选类构造器。 在python2.3， classmethod dict.fromkeys() 创建从keys列表中一个新字典， 相等的python如下：
class Dict:
    . . .
    def fromkeys(klass, iterable, value=None):
        "Emulate dict_fromkeys() in Objects/dictobject.c"
        d = klass()
        for key in iterable:
            d[key] = value
        return d
    fromkeys = classmethod(fromkeys)
现在一个唯一key的字典可以如下创建：
>>> Dict.fromkeys('abracadabra')
{'a': None, 'r': None, 'b': None, 'c': None, 'd': None}
python版本classmethod如下：
class ClassMethod(object):
     "Emulate PyClassMethod_Type() in Objects/funcobject.c"

     def __init__(self, f):
          self.f = f

     def __get__(self, obj, klass=None):
          if klass is None:
               klass = type(obj)
          def newfunc(*args):
               return self.f(klass, *args)
          return newfunc


























